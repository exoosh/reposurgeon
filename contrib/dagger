#! /usr/bin/env python3
"""Analyze the graph defined by dependencies in a multiproject 
repository, and generate useful reports on them.

The multiproject repository is expected not to have
trunk/branches/tags structure, but rather to have project
subdirectories which themselves may have trunk/branches/tags 
structure.  Each project is a node of the graph, the relation 
is copies-to.

If a file named ".dagger" exists in the working directory,
commands in it are executed at startup.

A "goal" is a project that has been marked as being
interesting and should be preserved in the repository 
conversion.

Assumes "=" never occurs in any pathname and has been used to
substitute for a slash that should be ignored.  The "delimiter"
command can be used to set a different one.

Typical invocations:

dagger "read myrepo.see" "expunge"
dagger "read myrepo.see" "graph" | dot -Tpng | display

This tool is somewhat misnamed, as the dependency graph can
have cycles.

Copyright by Eric S. Raymond
SPDX-License-Identifier: BSD-2-Clause
"""

import cmd, os.path, sys, copy, shlex

class Copy:
    def __init__(self, interpreter, revision, target, from_rev, from_path):
        self.interpreter = interpreter
        self.revision = revision
        self.target = target
        self.from_rev = from_rev
        self.from_path = from_path
    def interior(self):
        return self.interpreter.get_project(self.target) == self.interpreter.get_project(self.from_path)
    def __str__(self):
        return "%-5s %s <- %s:%s" % (self.revision, self.target, self.from_rev, self.from_path)

class Dagger(cmd.Cmd):
    "Multiproject repository explorer."
    def __init__(self, name=None):
        cmd.Cmd.__init__(self)
        self.prompt = "> "
        self.projects = set()
        self.depends_on = set()
        self.sources = set()
        self.goals = set()
        self.supers = set()
        self.inbound = {}
        self.outbound = {}
        self.copies = []
        self.irregular = []
        self.revcount = ""
        self.delimiter = "="

    def present(self, s):
        return s.replace(self.delimiter, "/")

    def transform(self, path):
        for topseg in self.supers:
            if path.startswith(topseg + "/")  and (len(path) > len(topseg)+1):
                path = path.replace(topseg + "/", topseg + self.delimiter, 1)
        return path
    
    def display(self, lst, wrapped):
        for item in sorted(lst):
            decorated = self.present(item)
            if wrapped:
                decorated = "'^" + decorated + "'"
            sys.stdout.write(" " + decorated)
        sys.stdout.write("\n")

    def get_project(self, path):
        for prefix in self.supers:
            if path.startswith(prefix + "/"):
                return "/".join(path.split("/")[:2])
        return path.split("/")[0]
    
    def oddcheck(self, path, line):
        parts = path.split("/")
        stdlayout = {"trunk", "branches", "tags"} 
        if len(parts) == 1 or (parts[0] in stdlayout) or (parts[1] not in stdlayout) or (len(parts) >= 3 and parts[2] in stdlayout):
            self.irregular.append(line)

    def copies_from(self, t, s):
        return (t, s) in self.depends_on

    def copies_to(self, s, t):
        return (t, s) in self.depends_on

    def closure(self, startpoints, relation):
        "Compute transitive closure of a set of project directories under a specified relation"
        closure = startpoints.copy()
        while True:
            addset = set()
            for item in closure:
                for possibility in self.projects:
                    if relation(item, possibility) and possibility not in closure:
                        addset.add(possibility)
            if len(addset) > 0:
                closure = closure.union(addset)
            else:
                break
        return closure

    def get_project_set(self, line):
        "Parse a list of projects from a line, using shell-like quoting if required"
        return set([self.transform(f) for f in shlex.split(line)])
    
    def help_intro(self):
        print(__doc__)

    def help_read(self):
        sys.stdout.write("""
Read a "repocutter see" report and compute the dependency graph
amomg top-level branches.  If a second argument is given, it sets the 
uppermost revision to be analyzed.
""")
    def do_read(self, line):
        cfields = line.split()
        for dline in open(cfields[0]):
            if "propset" in dline:
                continue
            fields = dline.split()
            number = fields.pop(0)
            op = fields.pop(0)
            self.revcount = number.split("-")[0]
            if op == "add":
                path = self.transform(" ".join(fields))
                self.oddcheck(path, dline)
                project = self.get_project(path)
                if project.endswith("/") and project[:-1] in self.supers:
                    continue
                self.projects.add(project)
            elif op == "copy":
                try:
                    ind = fields.index("from")
                except ValueError:
                    sys.stderr.write("%s: no from field in '%s'" % (sys.argv[0], dline.strip()))
                    raise SystemExit(1)
                target = self.transform(" ".join(fields[:ind]))
                self.oddcheck(target, dline)
                targetdir = self.get_project(target)
                if target.endswith("/") and targetdir[:-1] in self.supers:
                    sys.stderr.write("%s: unexpected copy to super %s at r%s\n" % (sys.argv[0], targetdir, number)) 
                self.projects.add(targetdir)
                source = " ".join(fields[ind+1:])
                self.oddcheck(source, dline)
                sourcerev = source.split(":")[0]
                source = self.transform(source.split(":")[1])
                sourcedir = self.get_project(source)
                self.copies.append(Copy(self, number, target, sourcerev, source))
                if sourcedir != targetdir and sourcedir not in self.supers and targetdir not in self.supers:
                    self.sources.add(sourcedir)
                    self.depends_on.add((targetdir, sourcedir))
                    if not targetdir in self.inbound.keys():
                        self.inbound[targetdir] = set()
                    self.inbound[targetdir].add(sourcedir)
                    if not sourcedir in self.outbound.keys():
                        self.outbound[sourcedir] = set()
                    self.outbound[sourcedir].add(targetdir)
                elif op == "change" or op == "delete":
                    self.oddcheck(self.transform(" ".join(fields)), dline)
            if len(cfields) > 1 and self.revcount == cfields[1]:
                print("Stopped")
                break
        return False

    def help_supers(self):
        sys.stdout.write("""
Declare the named directories to be supers - each *subdirectory* of them
is treated as a project for dependency-tracking purposes. Must be done before
read to be effective.
""")
    def do_supers(self, line):
        self.supers = self.supers.union(self.get_project_set(line))
        return False
        
    def do_goals(self, line):
        "Designate a set of projects as goals to be preserved in the conversion."
        self.goals = self.goals.union(self.get_project_set(line))
        return False
        
    def do_list(self, line):
        "List the contents of a property. With no argument, list defined properties."
        if line == "":
            self.display(["sources", "projects", "supers", "goals"], False)
        elif line == "sources":
            self.display(self.sources, False) 
        elif line == "projects":
            self.display(self.projects, False)
        elif line == "supers":
            self.display(self.supers, False)
        elif line == "goals":
            self.display(self.goals, False)
        else:
            print("No such property.")
        return False

    def do_upstream(self, line):
        "Display the copies-from closure of a set of project directories."
        print({self.present(p) for p in self.closure(self.get_project_set(line), self.copies_from)})
        return False

    def do_downstream(self, line):
        "Display the copies-to closure of a set of project directories."
        print({self.present(p) for p in self.closure(self.get_project_set(line), self.copies_to)})
        return False
    
    def do_EOF(self, _unused):
        "Terminate the interpreter."
        sys.stdout.write("\n")
        return True

    def help_expunge(self):
        sys.stdout.write("""
Generates a repocutter expunge command to strip out all project directories
the goals do not depend on.  The result is the complement relative to the
list of projects of the transitive completion of the depends-on relationship.
""")
    def do_expunge(self, line):
        if not self.depends_on:
            print("No dependency list")
            return False
        dependencies = self.closure(self.get_project_set(line), self.copies_from)
        sys.stdout.write('repocutter expunge \\\n')
        self.display(self.projects - dependencies, True)
        return False

    def help_sift(self):
        sys.stdout.write("""
Generates a repocutter sift command to select all project directories
the goals depend on.  The result is the the transitive completion of the
depends-on relationship.
""")
    def do_sift(self, line):
        if not self.depends_on:
            print("No dependency list")
            return False
        dependencies = self.closure(self.get_project_set(line), self.copies_from)
        sys.stdout.write('repocutter sift \\\n')
        self.display(dependencies, False)
        return False

    def do_terminals(self, _line):
        "List (non-endpoint) projects with no dependents."
        terminals = set()
        for project in self.projects:
            if project not in self.goals:
                for (target, source) in self.depends_on:
                    if source == project:
                        break
                else:
                    terminals.add(self.present(project))
        self.display(terminals, False)

    def do_swapcheck(self, line):
        "Display all operation with paths that won't swap to a canonical form."
        for line in self.irregular:
            sys.stdout.write(line)
    
    def help_graph(self):
        sys.stdout.write("""
Dump the dependency graph in DOT notation.  Display it
like this:

graph | dot -Tpng | display &

The arrow relationship is "is copied to".

Goals are shown as boxes rather than ovals.
""")
    def do_graph(self, _line):
        sys.stdout.write("digraph {\n")
        for project in self.goals:
            sys.stdout.write('\t"%s" [shape=box];\n' % (self.present(project)))
        for project in self.projects - self.goals:
            if not project in self.outbound.keys():
                sys.stdout.write('\t"%s" [color=green,style=filled];\n' % (self.present(project)))
        for (target, source) in self.depends_on:
            sys.stdout.write('\t"%s" -> "%s";\n' % (self.present(source), self.present(target)))
        sys.stdout.write("}\n")
    
    def do_stats(self, _unused):
        "Print statistics on the DAG."
        print("%s revisions" % self.revcount)
        print("%d dependencies" % len(self.depends_on))
        print("%d projects" % len(self.projects))
        print("%d goals" % len(self.goals))
        return False

    def do_delimiter(self, line):
        "Set the delimiter used for supers."
        self.delimiter = line

    def do_copies(self, line):
        "Display all cross-project copies involving the specified prefix." 
        for copy in self.copies:
            if (copy.target.startswith(line) or copy.from_path.startswith(line)) and not copy.interior():
                print(copy)

    def cleanup(self):
        pass

def main():
    try:
        interpreter = Dagger()
        setup = []
        if os.path.exists(".dagger"):
            for line in open(".dagger"):
                if line.startswith("#"):
                    continue
                else:
                    setup.append(line.strip())
        if not sys.argv[1:]:
            sys.argv.append("-")
        try:
            for arg in setup + sys.argv[1:]:
                for acmd in arg.split(";"):
                    if acmd == '-':
                        interpreter.cmdloop()
                    else:
                        interpreter.onecmd(interpreter.precmd(acmd))
        finally:
            interpreter.cleanup()
    except KeyboardInterrupt:
        sys.stdout.write("\n")

if __name__ == '__main__':
    main()
