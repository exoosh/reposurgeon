#! /usr/bin/env python3
"""Analyze dependencies in a multiproject repository 
and generate useful reports on them.

The multiproject repository is expected not to have
trunk/branches/tags structure, but rather to have project
subdirectories which themselves may have trunk/branches/tags 
structure.

If a file named ".multiex" exists in the working directory,
commands in it are executed at startup.

An "endpoint" is projct tha6 has neenm marked as being
interesting and should be preserved in the repository 
conversion.

Sssumes "=" never occurs in any pathname and has been used ti
subtitute for a slash that should be ignored.  To use a different
out-of-band character you wiill need to tweak the code

Typical invocation:

multiex "read myrepo.see" "expunge"

Copyright by Eric S. Raymond
SPDX-License-Identifier: BSD-2-Clause

"""

import cmd, os.path, sys

class Multiex(cmd.Cmd):
    "Multiproject repository explorer."
    def __init__(self, name=None):
        cmd.Cmd.__init__(self)
        self.do_clear("")
        self.prompt = "> "
        self.revcount = ""
        self.delimiter = "="

    def present(self, s):
        return s.replace(self.delimiter, "/")

    def transform(self, path):
        for topseg in self.pushdowns:
            if path.startswith(topseg + "/")  and (len(path) > len(topseg)+1):
                path = path.replace(topseg + "/", topseg + self.delimiter, 1)
        return path
    
    def display(self, lst, wrapped):
        for item in sorted(lst):
            decorated = self.present(item)
            if wrapped:
                decorated = "'^" + decorated + "'"
            sys.stdout.write(" " + decorated)
        sys.stdout.write("\n")

    def get_project(self, path):
        for prefix in self.pushdowns:
            if path.startswith(prefix + "/"):
                return "/".join(path.split("/")[:2])
        return path.split("/")[0]
        
    def closure(self, endpoints):
        "Compute transitive closure of a set of project directories under depends-on"
        closure = endpoints.copy()
        while True:
            addset = set()
            for item in closure:
                for (t, s) in self.depends_on:
                    if t == item and s not in closure:
                        addset.add(s)
            if len(addset) > 0:
                closure = closure.union(addset)
            else:
                break
        return closure

    def help_intro(self):
        print(__doc__)

    def help_read(self):
        sys.stdout.write("""
Read a "repocutter see" report and compute the dependency graph
amomg top-level branches.  If a second argument is given, it sets the 
uppermost revision to be analyzed.
""")
    def do_read(self, line):
        cfields = line.split()
        for dline in open(cfields[0]):
            if "propset" in dline:
                continue
            fields = dline.split()
            number = fields.pop(0)
            op = fields.pop(0)
            self.revcount = number.split("-")[0]
            if op == "add":
                path = self.transform(" ".join(fields))
                project = self.get_project(path)
                if project.endswith("/") and project[:-1] in self.pushdowns:
                    continue
                self.projects.add(project)
            elif op == "copy":
                try:
                    ind = fields.index("from")
                except ValueError:
                    sys.stderr.write("%s: no from field in '%s'" % (sys.argv[0], dline.strip()))
                    raise SystemExit(1)
                target = " ".join(fields[:ind])
                target = self.get_project(self.transform(target))
                if target.endswith("/") and target[:-1] in self.pushdowns:
                    sys.stderr.write("%s: unexpected copy to pushdown %s at r%s\n" % (sys.argv[0], target, number)) 
                self.projects.add(target)
                source = " ".join(fields[ind+1:])
                source = self.get_project(self.transform(source.split(":")[1]))
                if source != target and source not in self.pushdowns and target not in self.pushdowns:
                    self.sources.add(source)
                    self.depends_on.add((target, source))
                    if not target in self.inbound.keys():
                        self.inbound[target] = set()
                    self.inbound[target].add(source)
                    if not source in self.outbound.keys():
                        self.outbound[source] = set()
                    self.outbound[source].add(target)
            if len(cfields) > 1 and self.revcount == cfields[1]:
                print("Stopped")
                break
        return False

    def do_clear(self, _line):
        "Clear the dependency graph, projects list, and sources list."
        self.projects = set()
        self.depends_on = set()
        self.sources = set()
        self.endpoints = set()
        self.pushdowns = set()
        self.inbound = {}
        self.outbound = {}

    def help_pushdown(self):
        sys.stdout.write("""
Declare the named directories to be pushdowns - each *subdirectory* of them
is treated as a project for dependency-tracking purposes. Only affects 
following read operations.
""")
    def do_pushdown(self, line):
        self.pushdowns = self.pushdowns.union(set(line.split()))
        return False
        
    def do_endpoints(self, line):
        "Designate a set of projects as endpoints"
        self.endpoints = self.endpoints.union(set([self.transform(el) for el in line.split()]))
        return False
        
    def do_list(self, line):
        "List the contents of a property. With no argument, list defined properties."
        if line == "":
            self.display(["sources", "projects", "pushdowns", "endpoints"], False)
        elif line == "sources":
            self.display(self.sources, False) 
        elif line == "projects":
            self.display(self.projects, False)
        elif line == "pushdowns":
            self.display(self.pushdowns, False)
        elif line == "endpoints":
            self.display(self.endpoints, False)
        else:
            print("No such property.")
        return False
        
    def do_EOF(self, _unused):
        "Terminate the interpreter."
        sys.stdout.write("\n")
        return True

    def help_expunge(self):
        sys.stdout.write("""
Requires an argument list of projects deemed interesting.

Generates a repocutter expunge command to strip out all project directories
the interesting set does not depend on.  The result is the complement
relative to the list of projects of the transitive completion of the
depends-on relationship.
""")
    def do_expunge(self, line):
        if not self.depends_on:
            print("No dependency list")
            return False
        dependencies = self.closure(set(line.split()))
        sys.stdout.write('repocutter expunge \\\n')
        self.display(self.projects - dependencies, True)
        return False

    def help_sift(self):
        sys.stdout.write("""
Requires an argument list of projects deemed interesting.

Generates a repocutter sift command to strip out all project directories
the interesting set does not depend on.  The result is the the transitive
completion of the depends-on relationship.
""")
    def do_sift(self, line):
        if not self.depends_on:
            print("No dependency list")
            return False
        dependencies = self.closure(set(line.split()))
        sys.stdout.write('repocutter sift \\\n')
        self.display(dependencies, False)
        return False

    def do_downstream(self, line):
        "Generate a list of all projects that depend on a specified set."
        start_from = set(line.split())
        end_with = start_from.copy()
        while True:
            captured = set()
            for d in end_with:
                for (t,s) in self.depends_on:
                    if s == d:
                        captured.add(t)
            if not (captured - end_with):
                break
            else:
                end_with = end_with.union(captured)
        print(end_with-start_from)
        return False

    def do_terminals(self, _line):
        "List (non-endpoint) projects with no dependents."
        terminals = set()
        for project in self.projects:
            if project not in self.endpoints:
                for (target, source) in self.depends_on:
                    if source == project:
                        break
                else:
                    terminals.add(self.present(project))
        self.display(terminals, False)
    
    def help_graph(self):
        sys.stdout.write("""
Dump the dependency graph in DOT notation.  Display it
like this:

graph | dot -Tpng | display &

The arrow relationship is "is copied to".

Endpoints are shown as boxes rather than ovals.
""")
    def do_graph(self, _line):
        sys.stdout.write("digraph {\n")
        for project in self.endpoints:
            sys.stdout.write('\t"%s" [shape=box];\n' % (self.present(project)))
        for project in self.projects - self.endpoints:
            if not project in self.outbound.keys():
                sys.stdout.write('\t"%s" [color=green,style=filled];\n' % (self.present(project)))
        for (target, source) in self.depends_on:
            sys.stdout.write('\t"%s" -> "%s";\n' % (self.present(source), self.present(target)))
        sys.stdout.write("}\n")
    
    def do_stats(self, _unused):
        "Print statistics on the repository segment."
        print("%s revisions" % self.revcount)
        print("%d dependencies" % len(self.depends_on))
        print("%d projects" % len(self.projects))
        print("%d endpoints" % len(self.endpoints))
        return False

    def do_delimiter(self, line):
        "Set the delimiter used for pushdowns."
        self.delimiter = line
    
    def cleanup(self):
        pass

def main():
    try:
        interpreter = Multiex()
        setup = []
        if os.path.exists(".multiex"):
            for line in open(".multiex"):
                if line.startswith("#"):
                    continue
                else:
                    setup.append(line.strip())
        if not sys.argv[1:]:
            sys.argv.append("-")
        try:
            for arg in setup + sys.argv[1:]:
                for acmd in arg.split(";"):
                    if acmd == '-':
                        interpreter.cmdloop()
                    else:
                        interpreter.onecmd(interpreter.precmd(acmd))
        finally:
            interpreter.cleanup()
    except KeyboardInterrupt:
        sys.stdout.write("\n")

if __name__ == '__main__':
    main()
